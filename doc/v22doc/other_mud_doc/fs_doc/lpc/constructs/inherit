LPC inherit 敘述:

語法: inherit 檔案完整路徑名;

說明:
    檔案完整路徑名 要用雙引號括起來. 如:
     	inherit "/std/user.c"
    通常, 常用的"被繼承"物件會由系統用 #define 定義常數, 如
        #define USER_OB "/std/user.c"
    那麼, 就可以用
	inherit USER_OB;
    
    inherit 敘述提供 LPC 繼承的能力, 沒錯, 就是 OOP 的概念, 繼承讓物件
  可以很安全跟很方便的使用其他物件所定義的函數跟變數. 由於 MudOS 驅動
  程式內部會儲存整體變數, 然後把檔案分開編譯, 因此各個物件可以彼此分享
  已經編譯好的物件, 當然, 這些物件彼此有自己的整體跟局部變數可以使用,
  例如: 物件 A, B, 都繼承 C, 編譯 A 或 B 的時候不會讓編譯器重新編譯 C,
  不過, 如果 A 或 B 有重新定義整體變數的話, 不會引起重複定義的錯, 但是
  在 A 或 B 中會讓 C 的整體變數失效, 也就是 A 或 B 的宣告會"蓋過" C 中
  的宣告, 如果沒有在 A 或 B 中重複宣告的話, 當然就會使用 C 的宣告囉.
  還有, 上述的重複宣告並不影響 C 自己的變數.

    現在再假設 A 繼承了 B, 物件 A 可以定義跟物件 B 中相同名稱的函數或變數,
  如前所述, A 的引用會自動"蓋過" B 的, 不過如果只是這樣的話, 繼承就不會那
  麼特殊了. 如果你因為同名, 又想引用 B 的函數或變數, 可以使用 '::' 來引用.
  例如 A 繼承了 B, 而且兩個都各自定義 query_long(); 在 A 使用 query_long()
  的時候, 是使用到 A 定義的函數, 如果要在 A 使用 /std/ 的 query_long(),
  那就可以用 B::query_long(); 不過, 如果是同名變數的引用, 則只能透過 B 中
  定義的函數來存取, 這是為了物件的概念產生的.
    此外, B 可以選擇是否要讓別的物件繼承函數或整體變數, 禁止的方式是以
  static 來修飾函數或變數.
    另外一點, 如果 B 重新編譯的化, A 也只會用到舊的 B, 除非 A 在 B 之後也
  重新編譯過.

    這兒允許多重繼承, 也就是說, 在一個物件內可以寫多行的 inherit 敘述. 假
  設 special.c 繼承 weapon.c 跟 armor.c, 而 weapon.c 跟 armor.c 也都提供
  了自己的 query_long(), 假設要讓 special.c 有時像 weapon, 有時像 armor,
  要像 weapon, 就可以用 weapon::query_long(), 要讓它像 armor 就用
  armor::query_long(), 要有自己的 long, 就直接定義 query_long() 並直接呼
  叫來用. '::' 又稱為 "引用子", 或是 "視域子", 也就是讓你引用祖先的函數,
  或者把函數加上適當的視域範圍, 這樣就不會"用錯", 也就是不會讓編譯程式
  "看錯", 所以稱為"視域子".

    請繼續參考跟 修飾子 有關的說明. 那邊會有如何隱藏函數跟變數宣告的說明
    (在前面有提到 static 這個修飾子).
